Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Arm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.robotParts;\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.Telemetry;\r\n\r\npublic class Arm extends RobotPart {\r\n\r\n    DcMotorEx armLeft;\r\n    DcMotorEx armRight;\r\n\r\n    int upperLimit = 3685;\r\n\r\n    ArmHeight armHeight;\r\n\r\n    private enum ArmHeight {\r\n        INTAKE(0),\r\n        LOW(150),\r\n        MID(400),\r\n        HIGH(650);\r\n//        CUSTOM(0);\r\n\r\n        private int position;\r\n        public int getPosition() {\r\n            return this.position;\r\n        }\r\n        public void setPosition(int position) {\r\n            this.position = position;\r\n        }\r\n        ArmHeight(int position) {\r\n            this.position = position;\r\n        }\r\n    }\r\n\r\n    private int armTarget = 0;\r\n\r\n    //    public void init(HardwareMap map, Telemetry.Item telemetry) {\r\n    public void init(HardwareMap map) {\r\n        armLeft = map.get(DcMotorEx.class, \"arm1\");\r\n        armRight = map.get(DcMotorEx.class, \"arm2\");\r\n\r\n        // reverse one motor\r\n        armLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n        // make sure arm stands still with power = 0\r\n        armLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        armRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        // motors\r\n        motors.put(\"armLeft\", armLeft);\r\n        motors.put(\"armRight\", armRight);\r\n        resetEncoders();\r\n    }\r\n\r\n    public void update(double power, Telemetry telemetry) {\r\n        int position = armLeft.getCurrentPosition();\r\n\r\n        if (position <= 0 && power <= 0) {\r\n            setPower(0);\r\n        }\r\n        else if (position >= upperLimit && power >= 0) {\r\n            setPower(0.001);\r\n        } else {\r\n            armLeft.setPower(power + 0.01);\r\n            armRight.setPower((power) * 0.63 + 0.01);\r\n        }\r\n        telemetry.addData(\"arm\", position);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Arm.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Arm.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Arm.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Arm.java	(date 1676995377190)
@@ -18,18 +18,14 @@
 
     private enum ArmHeight {
         INTAKE(0),
-        LOW(150),
-        MID(400),
-        HIGH(650);
-//        CUSTOM(0);
+        LOW(100),
+        MID(200),
+        HIGH(300);
 
         private int position;
         public int getPosition() {
             return this.position;
         }
-        public void setPosition(int position) {
-            this.position = position;
-        }
         ArmHeight(int position) {
             this.position = position;
         }
@@ -55,6 +51,15 @@
         resetEncoders();
     }
 
+    public void goToHeight(int position) {
+        double currentPos = armLeft.getCurrentPosition();
+        if (currentPos < position) {
+            armLeft.setPower(1);
+        } else if (currentPos > position) {
+            armLeft.setPower(-1);
+        }
+    }
+
     public void update(double power, Telemetry telemetry) {
         int position = armLeft.getCurrentPosition();
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagTry.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2021 OpenFTC Team\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode.auton;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.firstinspires.ftc.teamcode.drive.opmode.AprilTagDetection;\r\nimport org.firstinspires.ftc.teamcode.drive.opmode.AprilTagDetectionPipeline;\r\nimport org.openftc.easyopencv.OpenCvCamera;\r\nimport org.openftc.easyopencv.OpenCvCameraFactory;\r\nimport org.openftc.easyopencv.OpenCvCameraRotation;\r\n\r\nimport java.util.ArrayList;\r\n\r\n@Autonomous\r\npublic class AprilTagTry extends LinearOpMode\r\n{\r\n    OpenCvCamera camera;\r\n    AprilTagDetectionPipeline aprilTagDetectionPipeline;\r\n\r\n    static final double FEET_PER_METER = 3.28084;\r\n\r\n    // Lens intrinsics\r\n    // UNITS ARE PIXELS\r\n    // NOTE: this calibration is for the C920 webcam at 800x448.\r\n    // You will need to do your own calibration for other configurations!\r\n    double fx = 578.272;\r\n    double fy = 578.272;\r\n    double cx = 402.145;\r\n    double cy = 221.506;\r\n\r\n    // UNITS ARE METERS\r\n    double tagsize = 0.166;\r\n\r\n    // Tag ID 18 from the 36h11 family\r\n    int LEFT = 1;\r\n    int MIDDLE = 2;\r\n\r\n    AprilTagDetection tagOfInterest = null;\r\n\r\n    @Override\r\n    public void runOpMode()\r\n    {\r\n        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        camera = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, \"Webcam 1\"), cameraMonitorViewId);\r\n        aprilTagDetectionPipeline = new AprilTagDetectionPipeline(tagsize, fx, fy, cx, cy);\r\n\r\n        camera.setPipeline(aprilTagDetectionPipeline);\r\n        camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()\r\n        {\r\n            @Override\r\n            public void onOpened()\r\n            {\r\n                camera.startStreaming(800,448, OpenCvCameraRotation.UPRIGHT);\r\n            }\r\n\r\n            @Override\r\n            public void onError(int errorCode)\r\n            {\r\n\r\n            }\r\n        });\r\n\r\n        telemetry.setMsTransmissionInterval(50);\r\n\r\n        /*\r\n         * The INIT-loop:\r\n         * This REPLACES waitForStart!\r\n         */\r\n        while (!isStarted() && !isStopRequested())\r\n        {\r\n            ArrayList<AprilTagDetection> currentDetections = aprilTagDetectionPipeline.getLatestDetections();\r\n\r\n            if(currentDetections.size() != 0)\r\n            {\r\n                boolean tagFound = false;\r\n\r\n                for(AprilTagDetection tag : currentDetections)\r\n                {\r\n                    if(tag.id == LEFT || tag.id == MIDDLE)\r\n                    {\r\n                        tagOfInterest = tag;\r\n                        tagFound = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if(tagFound)\r\n                {\r\n                    telemetry.addLine(\"Tag of interest is in sight!\\n\\nLocation data:\");\r\n                    tagToTelemetry(tagOfInterest);\r\n                }\r\n                else\r\n                {\r\n                    telemetry.addLine(\"Don't see tag of interest :(\");\r\n\r\n                    if(tagOfInterest == null)\r\n                    {\r\n                        telemetry.addLine(\"PRIDE\");\r\n                    }\r\n                    else\r\n                    {\r\n                        telemetry.addLine(\"\\nBut we HAVE seen the tag before; last seen at:\");\r\n                        tagToTelemetry(tagOfInterest);\r\n                    }\r\n                }\r\n\r\n            }\r\n            else\r\n            {\r\n                telemetry.addLine(\"Don't see tag of interest :(\");\r\n\r\n                if(tagOfInterest == null)\r\n                {\r\n                    telemetry.addLine(\"PRIDE\");\r\n                }\r\n                else\r\n                {\r\n                    telemetry.addLine(\"\\nBut we HAVE seen the tag before; last seen at:\");\r\n                    tagToTelemetry(tagOfInterest);\r\n                }\r\n\r\n            }\r\n\r\n            telemetry.update();\r\n            sleep(20);\r\n        }\r\n\r\n        /*\r\n         * The START command just came in: now work off the latest snapshot acquired\r\n         * during the init loop.\r\n         */\r\n\r\n        /* Update the telemetry */\r\n        if(tagOfInterest != null)\r\n        {\r\n            telemetry.addLine(\"Tag snapshot:\\n\");\r\n            tagToTelemetry(tagOfInterest);\r\n            telemetry.update();\r\n        }\r\n        else\r\n        {\r\n            telemetry.addLine(\"No tag snapshot available, it was never sighted during the init loop :(\");\r\n            telemetry.update();\r\n        }\r\n\r\n        /* Actually do something useful */\r\n\r\n        if (tagOfInterest == null) {\r\n            telemetry.addLine(\"RIGHT\");\r\n            telemetry.update();\r\n            // trajectory\r\n        } else if (tagOfInterest.id == LEFT) {\r\n            telemetry.addLine(\"LEFT\");\r\n            telemetry.update();\r\n            // trajectory\r\n        }\r\n        else if (tagOfInterest.id == MIDDLE) {\r\n            telemetry.addLine(\"MIDDLE\");\r\n            telemetry.update();\r\n            // trajectory\r\n        }\r\n\r\n\r\n        // other code\r\n\r\n\r\n        /* You wouldn't have this in your autonomous, this is just to prevent the sample from ending */\r\n        while (opModeIsActive()) {sleep(20);}\r\n    }\r\n\r\n    void tagToTelemetry(AprilTagDetection detection)\r\n    {\r\n        telemetry.addLine(String.format(\"\\nDetected tag ID=%d\", detection.id));\r\n        telemetry.addLine(String.format(\"Translation X: %.2f feet\", detection.pose.x*FEET_PER_METER));\r\n        telemetry.addLine(String.format(\"Translation Y: %.2f feet\", detection.pose.y*FEET_PER_METER));\r\n        telemetry.addLine(String.format(\"Translation Z: %.2f feet\", detection.pose.z*FEET_PER_METER));\r\n        telemetry.addLine(String.format(\"Rotation Yaw: %.2f degrees\", Math.toDegrees(detection.pose.yaw)));\r\n        telemetry.addLine(String.format(\"Rotation Pitch: %.2f degrees\", Math.toDegrees(detection.pose.pitch)));\r\n        telemetry.addLine(String.format(\"Rotation Roll: %.2f degrees\", Math.toDegrees(detection.pose.roll)));\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagTry.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagTry.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagTry.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagTry.java	(date 1676995377199)
@@ -192,12 +192,12 @@
 
     void tagToTelemetry(AprilTagDetection detection)
     {
-        telemetry.addLine(String.format("\nDetected tag ID=%d", detection.id));
-        telemetry.addLine(String.format("Translation X: %.2f feet", detection.pose.x*FEET_PER_METER));
-        telemetry.addLine(String.format("Translation Y: %.2f feet", detection.pose.y*FEET_PER_METER));
-        telemetry.addLine(String.format("Translation Z: %.2f feet", detection.pose.z*FEET_PER_METER));
-        telemetry.addLine(String.format("Rotation Yaw: %.2f degrees", Math.toDegrees(detection.pose.yaw)));
-        telemetry.addLine(String.format("Rotation Pitch: %.2f degrees", Math.toDegrees(detection.pose.pitch)));
-        telemetry.addLine(String.format("Rotation Roll: %.2f degrees", Math.toDegrees(detection.pose.roll)));
+//        telemetry.addLine(String.format("\nDetected tag ID=%d", detection.id));
+//        telemetry.addLine(String.format("Translation X: %.2f feet", detection.pose.x*FEET_PER_METER));
+//        telemetry.addLine(String.format("Translation Y: %.2f feet", detection.pose.y*FEET_PER_METER));
+//        telemetry.addLine(String.format("Translation Z: %.2f feet", detection.pose.z*FEET_PER_METER));
+//        telemetry.addLine(String.format("Rotation Yaw: %.2f degrees", Math.toDegrees(detection.pose.yaw)));
+//        telemetry.addLine(String.format("Rotation Pitch: %.2f degrees", Math.toDegrees(detection.pose.pitch)));
+//        telemetry.addLine(String.format("Rotation Roll: %.2f degrees", Math.toDegrees(detection.pose.roll)));
     }
 }
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagDetectionPipeline.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * Copyright (c) 2021 OpenFTC Team\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\n/*package org.firstinspires.ftc.teamcode.auton;\r\n\r\nimport org.opencv.calib3d.Calib3d;\r\nimport org.opencv.core.CvType;\r\nimport org.opencv.core.Mat;\r\nimport org.opencv.core.MatOfDouble;\r\nimport org.opencv.core.MatOfPoint2f;\r\nimport org.opencv.core.MatOfPoint3f;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.core.Point3;\r\nimport org.opencv.core.Scalar;\r\nimport org.opencv.imgproc.Imgproc;\r\nimport org.openftc.apriltag.AprilTagDetection;\r\nimport org.openftc.apriltag.AprilTagDetectorJNI;\r\nimport org.openftc.easyopencv.OpenCvPipeline;\r\n\r\nimport java.util.ArrayList;\r\n\r\nclass AprilTagDetectionPipeline extends OpenCvPipeline\r\n{\r\n    private long nativeApriltagPtr;\r\n    private Mat grey = new Mat();\r\n    private ArrayList<AprilTagDetection> detections = new ArrayList<>();\r\n\r\n    private ArrayList<AprilTagDetection> detectionsUpdate = new ArrayList<>();\r\n    private final Object detectionsUpdateSync = new Object();\r\n\r\n    Mat cameraMatrix;\r\n\r\n    Scalar blue = new Scalar(7,197,235,255);\r\n    Scalar red = new Scalar(255,0,0,255);\r\n    Scalar green = new Scalar(0,255,0,255);\r\n    Scalar white = new Scalar(255,255,255,255);\r\n\r\n    double fx;\r\n    double fy;\r\n    double cx;\r\n    double cy;\r\n\r\n    // UNITS ARE METERS\r\n    double tagsize;\r\n    double tagsizeX;\r\n    double tagsizeY;\r\n\r\n    private float decimation;\r\n    private boolean needToSetDecimation;\r\n    private final Object decimationSync = new Object();\r\n\r\n    public AprilTagDetectionPipeline(double tagsize, double fx, double fy, double cx, double cy)\r\n    {\r\n        this.tagsize = tagsize;\r\n        this.tagsizeX = tagsize;\r\n        this.tagsizeY = tagsize;\r\n        this.fx = fx;\r\n        this.fy = fy;\r\n        this.cx = cx;\r\n        this.cy = cy;\r\n\r\n        constructMatrix();\r\n\r\n        // Allocate a native context object. See the corresponding deletion in the finalizer\r\n        nativeApriltagPtr = AprilTagDetectorJNI.createApriltagDetector(AprilTagDetectorJNI.TagFamily.TAG_36h11.string, 3, 3);\r\n    }\r\n\r\n    @Override\r\n    public void finalize()\r\n    {\r\n        // Might be null if createApriltagDetector() threw an exception\r\n        if(nativeApriltagPtr != 0)\r\n        {\r\n            // Delete the native context we created in the constructor\r\n            AprilTagDetectorJNI.releaseApriltagDetector(nativeApriltagPtr);\r\n            nativeApriltagPtr = 0;\r\n        }\r\n        else\r\n        {\r\n            System.out.println(\"AprilTagDetectionPipeline.finalize(): nativeApriltagPtr was NULL\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public Mat processFrame(Mat input)\r\n    {\r\n        // Convert to greyscale\r\n        Imgproc.cvtColor(input, grey, Imgproc.COLOR_RGBA2GRAY);\r\n\r\n        synchronized (decimationSync)\r\n        {\r\n            if(needToSetDecimation)\r\n            {\r\n                AprilTagDetectorJNI.setApriltagDetectorDecimation(nativeApriltagPtr, decimation);\r\n                needToSetDecimation = false;\r\n            }\r\n        }\r\n\r\n        // Run AprilTag\r\n        detections = AprilTagDetectorJNI.runAprilTagDetectorSimple(nativeApriltagPtr, grey, tagsize, fx, fy, cx, cy);\r\n\r\n        synchronized (detectionsUpdateSync)\r\n        {\r\n            detectionsUpdate = detections;\r\n        }\r\n\r\n        // For fun, use OpenCV to draw 6DOF markers on the image. We actually recompute the pose using\r\n        // OpenCV because I haven't yet figured out how to re-use AprilTag's pose in OpenCV.\r\n        for(AprilTagDetection detection : detections)\r\n        {\r\n            Pose pose = poseFromTrapezoid(detection.corners, cameraMatrix, tagsizeX, tagsizeY);\r\n            drawAxisMarker(input, tagsizeY/2.0, 6, pose.rvec, pose.tvec, cameraMatrix);\r\n            draw3dCubeMarker(input, tagsizeX, tagsizeX, tagsizeY, 5, pose.rvec, pose.tvec, cameraMatrix);\r\n        }\r\n\r\n        return input;\r\n    }\r\n\r\n    public void setDecimation(float decimation)\r\n    {\r\n        synchronized (decimationSync)\r\n        {\r\n            this.decimation = decimation;\r\n            needToSetDecimation = true;\r\n        }\r\n    }\r\n\r\n    public ArrayList<AprilTagDetection> getLatestDetections()\r\n    {\r\n        return detections;\r\n    }\r\n\r\n    public ArrayList<AprilTagDetection> getDetectionsUpdate()\r\n    {\r\n        synchronized (detectionsUpdateSync)\r\n        {\r\n            ArrayList<AprilTagDetection> ret = detectionsUpdate;\r\n            detectionsUpdate = null;\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void constructMatrix()\r\n    {\r\n        //     Construct the camera matrix.\r\n        //\r\n        //      --         --\r\n        //     | fx   0   cx |\r\n        //     | 0    fy  cy |\r\n        //     | 0    0   1  |\r\n        //      --         --\r\n        //\r\n\r\n        cameraMatrix = new Mat(3,3, CvType.CV_32FC1);\r\n\r\n        cameraMatrix.put(0,0, fx);\r\n        cameraMatrix.put(0,1,0);\r\n        cameraMatrix.put(0,2, cx);\r\n\r\n        cameraMatrix.put(1,0,0);\r\n        cameraMatrix.put(1,1,fy);\r\n        cameraMatrix.put(1,2,cy);\r\n\r\n        cameraMatrix.put(2, 0, 0);\r\n        cameraMatrix.put(2,1,0);\r\n        cameraMatrix.put(2,2,1);\r\n    }\r\n\r\n    /**\r\n     * Draw a 3D axis marker on a detection. (Similar to what Vuforia does)\r\n     *\r\n     * @param buf the RGB buffer on which to draw the marker\r\n     * @param length the length of each of the marker 'poles'\r\n     * @param rvec the rotation vector of the detection\r\n     * @param tvec the translation vector of the detection\r\n     * @param cameraMatrix the camera matrix used when finding the detection\r\n\r\n    void drawAxisMarker(Mat buf, double length, int thickness, Mat rvec, Mat tvec, Mat cameraMatrix)\r\n    {\r\n        // The points in 3D space we wish to project onto the 2D image plane.\r\n        // The origin of the coordinate space is assumed to be in the center of the detection.\r\n        MatOfPoint3f axis = new MatOfPoint3f(\r\n                new Point3(0,0,0),\r\n                new Point3(length,0,0),\r\n                new Point3(0,length,0),\r\n                new Point3(0,0,-length)\r\n        );\r\n\r\n        // Project those points\r\n        MatOfPoint2f matProjectedPoints = new MatOfPoint2f();\r\n        Calib3d.projectPoints(axis, rvec, tvec, cameraMatrix, new MatOfDouble(), matProjectedPoints);\r\n        Point[] projectedPoints = matProjectedPoints.toArray();\r\n\r\n        // Draw the marker!\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[1], red, thickness);\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[2], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[0], projectedPoints[3], blue, thickness);\r\n\r\n        Imgproc.circle(buf, projectedPoints[0], thickness, white, -1);\r\n    }\r\n\r\n    void draw3dCubeMarker(Mat buf, double length, double tagWidth, double tagHeight, int thickness, Mat rvec, Mat tvec, Mat cameraMatrix)\r\n    {\r\n        //axis = np.float32([[0,0,0], [0,3,0], [3,3,0], [3,0,0],\r\n        //       [0,0,-3],[0,3,-3],[3,3,-3],[3,0,-3] ])\r\n\r\n        // The points in 3D space we wish to project onto the 2D image plane.\r\n        // The origin of the coordinate space is assumed to be in the center of the detection.\r\n        MatOfPoint3f axis = new MatOfPoint3f(\r\n                new Point3(-tagWidth/2, tagHeight/2,0),\r\n                new Point3( tagWidth/2, tagHeight/2,0),\r\n                new Point3( tagWidth/2,-tagHeight/2,0),\r\n                new Point3(-tagWidth/2,-tagHeight/2,0),\r\n                new Point3(-tagWidth/2, tagHeight/2,-length),\r\n                new Point3( tagWidth/2, tagHeight/2,-length),\r\n                new Point3( tagWidth/2,-tagHeight/2,-length),\r\n                new Point3(-tagWidth/2,-tagHeight/2,-length));\r\n\r\n        // Project those points\r\n        MatOfPoint2f matProjectedPoints = new MatOfPoint2f();\r\n        Calib3d.projectPoints(axis, rvec, tvec, cameraMatrix, new MatOfDouble(), matProjectedPoints);\r\n        Point[] projectedPoints = matProjectedPoints.toArray();\r\n\r\n        // Pillars\r\n        for(int i = 0; i < 4; i++)\r\n        {\r\n            Imgproc.line(buf, projectedPoints[i], projectedPoints[i+4], blue, thickness);\r\n        }\r\n\r\n        // Base lines\r\n        //Imgproc.line(buf, projectedPoints[0], projectedPoints[1], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[1], projectedPoints[2], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[2], projectedPoints[3], blue, thickness);\r\n        //Imgproc.line(buf, projectedPoints[3], projectedPoints[0], blue, thickness);\r\n\r\n        // Top lines\r\n        Imgproc.line(buf, projectedPoints[4], projectedPoints[5], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[5], projectedPoints[6], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[6], projectedPoints[7], green, thickness);\r\n        Imgproc.line(buf, projectedPoints[4], projectedPoints[7], green, thickness);\r\n    }\r\n\r\n    /**\r\n     * Extracts 6DOF pose from a trapezoid, using a camera intrinsics matrix and the\r\n     * original size of the tag.\r\n     *\r\n     * @param points the points which form the trapezoid\r\n     * @param cameraMatrix the camera intrinsics matrix\r\n     * @param tagsizeX the original width of the tag\r\n     * @param tagsizeY the original height of the tag\r\n     * @return the 6DOF pose of the camera relative to the tag\r\n\r\n    Pose poseFromTrapezoid(Point[] points, Mat cameraMatrix, double tagsizeX , double tagsizeY)\r\n    {\r\n        // The actual 2d points of the tag detected in the image\r\n        MatOfPoint2f points2d = new MatOfPoint2f(points);\r\n\r\n        // The 3d points of the tag in an 'ideal projection'\r\n        Point3[] arrayPoints3d = new Point3[4];\r\n        arrayPoints3d[0] = new Point3(-tagsizeX/2, tagsizeY/2, 0);\r\n        arrayPoints3d[1] = new Point3(tagsizeX/2, tagsizeY/2, 0);\r\n        arrayPoints3d[2] = new Point3(tagsizeX/2, -tagsizeY/2, 0);\r\n        arrayPoints3d[3] = new Point3(-tagsizeX/2, -tagsizeY/2, 0);\r\n        MatOfPoint3f points3d = new MatOfPoint3f(arrayPoints3d);\r\n\r\n        // Using this information, actually solve for pose\r\n        Pose pose = new Pose();\r\n        Calib3d.solvePnP(points3d, points2d, cameraMatrix, new MatOfDouble(), pose.rvec, pose.tvec, false);\r\n\r\n        return pose;\r\n    }\r\n\r\n    /*\r\n     * A simple container to hold both rotation and translation\r\n     * vectors, which together form a 6DOF pose.\r\n\r\n    class Pose\r\n    {\r\n        Mat rvec;\r\n        Mat tvec;\r\n\r\n        public Pose()\r\n        {\r\n            rvec = new Mat();\r\n            tvec = new Mat();\r\n        }\r\n\r\n        public Pose(Mat rvec, Mat tvec)\r\n        {\r\n            this.rvec = rvec;\r\n            this.tvec = tvec;\r\n        }\r\n    }\r\n}*/
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagDetectionPipeline.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagDetectionPipeline.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagDetectionPipeline.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AprilTagDetectionPipeline.java	(date 1676995377211)
@@ -19,8 +19,10 @@
  * SOFTWARE.
  */
 
-/*package org.firstinspires.ftc.teamcode.auton;
+package org.firstinspires.ftc.teamcode.auton;
 
+import org.firstinspires.ftc.teamcode.drive.opmode.AprilTagDetection;
+import org.firstinspires.ftc.teamcode.drive.opmode.AprilTagDetectorJNI;
 import org.opencv.calib3d.Calib3d;
 import org.opencv.core.CvType;
 import org.opencv.core.Mat;
@@ -31,8 +33,6 @@
 import org.opencv.core.Point3;
 import org.opencv.core.Scalar;
 import org.opencv.imgproc.Imgproc;
-import org.openftc.apriltag.AprilTagDetection;
-import org.openftc.apriltag.AprilTagDetectorJNI;
 import org.openftc.easyopencv.OpenCvPipeline;
 
 import java.util.ArrayList;
@@ -192,7 +192,7 @@
      * @param rvec the rotation vector of the detection
      * @param tvec the translation vector of the detection
      * @param cameraMatrix the camera matrix used when finding the detection
-
+     */
     void drawAxisMarker(Mat buf, double length, int thickness, Mat rvec, Mat tvec, Mat cameraMatrix)
     {
         // The points in 3D space we wish to project onto the 2D image plane.
@@ -267,7 +267,7 @@
      * @param tagsizeX the original width of the tag
      * @param tagsizeY the original height of the tag
      * @return the 6DOF pose of the camera relative to the tag
-
+     */
     Pose poseFromTrapezoid(Point[] points, Mat cameraMatrix, double tagsizeX , double tagsizeY)
     {
         // The actual 2d points of the tag detected in the image
@@ -291,7 +291,7 @@
     /*
      * A simple container to hold both rotation and translation
      * vectors, which together form a 6DOF pose.
-
+     */
     class Pose
     {
         Mat rvec;
@@ -309,4 +309,4 @@
             this.tvec = tvec;
         }
     }
-}*/
\ No newline at end of file
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dracula.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\n\r\nimport org.firstinspires.ftc.teamcode.robotParts.Arm;\r\nimport org.firstinspires.ftc.teamcode.robotParts.Drivetrain;\r\nimport org.firstinspires.ftc.teamcode.robotParts.Intake;\r\n\r\n@TeleOp\r\npublic class dracula extends LinearOpMode {\r\n    Drivetrain drivetrain = new Drivetrain();\r\n    Arm arm = new Arm();\r\n    Intake intake = new Intake();\r\n\r\n    @Override\r\n    public void runOpMode() throws InterruptedException {\r\n        drivetrain.init(hardwareMap);\r\n        arm.init(hardwareMap);\r\n        intake.init(hardwareMap);\r\n\r\n        waitForStart();\r\n\r\n        if (isStopRequested()) return;\r\n\r\n        while (opModeIsActive()) {\r\n            double y = -gamepad1.left_stick_y; // y direction is reversed\r\n            double x = gamepad1.left_stick_x;\r\n            double rotate = gamepad1.right_stick_x;\r\n\r\n            double armPower = -gamepad2.right_stick_y;\r\n\r\n            boolean up = gamepad2.dpad_up;\r\n            boolean down = gamepad2.dpad_down;\r\n\r\n            drivetrain.drive(y, x, rotate);\r\n            arm.update(armPower, telemetry);\r\n            intake.update(up, down);\r\n\r\n            telemetry.addData(\"arm power\", armPower);\r\n            telemetry.update();\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dracula.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dracula.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dracula.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/dracula.java	(date 1676995377262)
@@ -27,11 +27,13 @@
             double y = -gamepad1.left_stick_y; // y direction is reversed
             double x = gamepad1.left_stick_x;
             double rotate = gamepad1.right_stick_x;
+            double speedAdder = gamepad1.right_trigger * 0.4;
 
             double armPower = -gamepad2.right_stick_y;
 
             boolean up = gamepad2.dpad_up;
             boolean down = gamepad2.dpad_down;
+            Drivetrain.maxSpeed = 0.6 + speedAdder;
 
             drivetrain.drive(y, x, rotate);
             arm.update(armPower, telemetry);
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\r\n\r\nimport com.acmerobotics.dashboard.config.Config;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\n\r\n/*\r\n * Constants shared between multiple drive types.\r\n *\r\n * Constants generated by LearnRoadRunner.com/drive-constants\r\n *\r\n * TODO: Tune or adjust the following constants to fit your robot. Note that the non-final\r\n * fields may also be edited through the dashboard (connect to the robot's WiFi network and\r\n * navigate to https://192.168.49.1:8080/dash). Make sure to save the values here after you\r\n * adjust them in the dashboard; **config variable changes don't persist between app restarts**.\r\n *\r\n * These are not the only parameters; some are located in the localizer classes, drive base classes,\r\n * and op modes themselves.\r\n */\r\n@Config\r\npublic class DriveConstants {\r\n\r\n    /*\r\n     * These are motor constants that should be listed online for your motors.\r\n     */\r\n    public static final double TICKS_PER_REV = 537.6;\r\n    public static final double MAX_RPM = 312;\r\n\r\n    /*\r\n     * Set RUN_USING_ENCODER to true to enable built-in hub velocity control using drive encoders.\r\n     * Set this flag to false if drive encoders are not present and an alternative localization\r\n     * method is in use (e.g., tracking wheels).\r\n     *\r\n     * If using the built-in motor velocity PID, update MOTOR_VELO_PID with the tuned coefficients\r\n     * from DriveVelocityPIDTuner.\r\n     */\r\n    public static final boolean RUN_USING_ENCODER = false;\r\n    public static PIDFCoefficients MOTOR_VELO_PID = new PIDFCoefficients(0, 0, 0,\r\n      getMotorVelocityF(MAX_RPM / 60 * TICKS_PER_REV));\r\n\r\n    /*\r\n     * These are physical constants that can be determined from your robot (including the track\r\n     * width; it will be tune empirically later although a rough estimate is important). Users are\r\n     * free to chose whichever linear distance unit they would like so long as it is consistently\r\n     * used. The default values were selected with inches in mind. Road runner uses radians for\r\n     * angular distances although most angular parameters are wrapped in Math.toRadians() for\r\n     * convenience. Make sure to exclude any gear ratio included in MOTOR_CONFIG from GEAR_RATIO.\r\n     */\r\n    public static double WHEEL_RADIUS = 1.8898; // in\r\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed\r\n    public static double TRACK_WIDTH = 13; // in\r\n\r\n    /*\r\n     * These are the feedforward parameters used to model the drive motor behavior. If you are using\r\n     * the built-in velocity PID, *these values are fine as is*. However, if you do not have drive\r\n     * motor encoders or have elected not to use them for velocity control, these values should be\r\n     * empirically tuned.\r\n     */\r\n    public static double kV = 1.0 / rpmToVelocity(MAX_RPM);\r\n    public static double kA = 0;\r\n    public static double kStatic = 0;\r\n\r\n    /*\r\n     * These values are used to generate the trajectories for you robot. To ensure proper operation,\r\n     * the constraints should never exceed ~80% of the robot's actual capabilities. While Road\r\n     * Runner is designed to enable faster autonomous motion, it is a good idea for testing to start\r\n     * small and gradually increase them later after everything is working. All distance units are\r\n     * inches.\r\n     */\r\n    /*\r\n     * Note from LearnRoadRunner.com:\r\n     * The velocity and acceleration constraints were calculated based on the following equation:\r\n     * ((MAX_RPM / 60) * GEAR_RATIO * WHEEL_RADIUS * 2 * Math.PI) * 0.85\r\n     * Resulting in 52.48291908330528 in/s.\r\n     * This is only 85% of the theoretical maximum velocity of the bot, following the recommendation above.\r\n     * This is capped at 85% because there are a number of variables that will prevent your bot from actually\r\n     * reaching this maximum velocity: voltage dropping over the game, bot weight, general mechanical inefficiencies, etc.\r\n     * However, you can push this higher yourself if you'd like. Perhaps raise it to 90-95% of the theoretically \r\n     * max velocity. The theoretically maximum velocity is 61.74461068624151 in/s.\r\n     * Just make sure that your bot can actually reach this maximum velocity. Path following will be detrimentally\r\n     * affected if it is aiming for a velocity not actually possible.\r\n     * \r\n     * The maximum acceleration is somewhat arbitrary and it is recommended that you tweak this yourself based on\r\n     * actual testing. Just set it at a reasonable value and keep increasing until your path following starts\r\n     * to degrade. As of now, it simply mirrors the velocity, resulting in 52.48291908330528 in/s/s\r\n     *\r\n     * Maximum Angular Velocity is calculated as: maximum velocity / trackWidth * (180 / Math.PI) but capped at 360°/s.\r\n     * You are free to raise this on your own if you would like. It is best determined through experimentation.\r\n     \r\n     */\r\n    public static double MAX_VEL = 52.48291908330528;\r\n    public static double MAX_ACCEL = 52.48291908330528;\r\n    public static double MAX_ANG_VEL = Math.toRadians(231.31152000000003);\r\n    public static double MAX_ANG_ACCEL = Math.toRadians(231.31152000000003);\r\n\r\n\r\n    public static double encoderTicksToInches(double ticks) {\r\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\r\n    }\r\n\r\n    public static double rpmToVelocity(double rpm) {\r\n        return rpm * GEAR_RATIO * 2 * Math.PI * WHEEL_RADIUS / 60.0;\r\n    }\r\n\r\n    public static double getMotorVelocityF(double ticksPerSecond) {\r\n      // see https://docs.google.com/document/d/1tyWrXDfMidwYyP_5H4mZyVgaEswhOC35gvdmP-V-5hA/edit#heading=h.61g9ixenznbx\r\n      return 32767 / ticksPerSecond;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/DriveConstants.java	(date 1676995377227)
@@ -22,7 +22,7 @@
     /*
      * These are motor constants that should be listed online for your motors.
      */
-    public static final double TICKS_PER_REV = 537.6;
+    public static final double TICKS_PER_REV = 537.7;
     public static final double MAX_RPM = 312;
 
     /*
@@ -47,7 +47,7 @@
      */
     public static double WHEEL_RADIUS = 1.8898; // in
     public static double GEAR_RATIO = 1; // output (wheel) speed / input (motor) speed
-    public static double TRACK_WIDTH = 13; // in
+    public static double TRACK_WIDTH = 12; // in
 
     /*
      * These are the feedforward parameters used to model the drive motor behavior. If you are using
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\r\n\r\nimport androidx.annotation.NonNull;\r\n\r\nimport com.acmerobotics.dashboard.config.Config;\r\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\r\nimport com.acmerobotics.roadrunner.localization.ThreeTrackingWheelLocalizer;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.teamcode.util.Encoder;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/*\r\n * Sample tracking wheel localizer implementation assuming the standard configuration:\r\n *\r\n *    /--------------\\\r\n *    |     ____     |\r\n *    |     ----     |\r\n *    | ||        || |\r\n *    | ||        || |\r\n *    |              |\r\n *    |              |\r\n *    \\--------------/\r\n *\r\n */\r\n@Config\r\npublic class StandardTrackingWheelLocalizer extends ThreeTrackingWheelLocalizer {\r\n    public static double TICKS_PER_REV = 8192;\r\n    public static double WHEEL_RADIUS = 0.98; // in\r\n    public static double GEAR_RATIO = 1; // output (wheel) speed / input (encoder) speed\r\n\r\n    public static double LATERAL_DISTANCE = 4.3; // in; distance between the left and right wheels\r\n    public static double FORWARD_OFFSET = -1.5; // in; offset of the lateral wheel\r\n\r\n    public static double X_MULTIPLIER = 1; // Multiplier in the X direction\r\n    public static double Y_MULTIPLIER = 1; // Multiplier in the Y direction\r\n\r\n    private Encoder leftEncoder, rightEncoder, frontEncoder;\r\n\r\n    public StandardTrackingWheelLocalizer(HardwareMap hardwareMap) {\r\n        super(Arrays.asList(\r\n                new Pose2d(0, LATERAL_DISTANCE / 2, 0), // left\r\n                new Pose2d(0, -LATERAL_DISTANCE / 2, 0), // right\r\n                new Pose2d(FORWARD_OFFSET, 0, Math.toRadians(90)) // front\r\n        ));\r\n\r\n        leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"leftFront\"));\r\n        rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"rightFront\"));\r\n        frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, \"leftBack\"));\r\n\r\n        // TODO: reverse any encoders using Encoder.setDirection(Encoder.Direction.REVERSE)\r\n        leftEncoder.setDirection(Encoder.Direction.REVERSE);\r\n    }\r\n\r\n    public static double encoderTicksToInches(double ticks) {\r\n        return WHEEL_RADIUS * 2 * Math.PI * GEAR_RATIO * ticks / TICKS_PER_REV;\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public List<Double> getWheelPositions() {\r\n        return Arrays.asList(\r\n                encoderTicksToInches(leftEncoder.getCurrentPosition() * X_MULTIPLIER),\r\n                encoderTicksToInches(rightEncoder.getCurrentPosition() * X_MULTIPLIER),\r\n                encoderTicksToInches(frontEncoder.getCurrentPosition() * Y_MULTIPLIER)\r\n        );\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public List<Double> getWheelVelocities() {\r\n        // TODO: If your encoder velocity can exceed 32767 counts / second (such as the REV Through Bore and other\r\n        //  competing magnetic encoders), change Encoder.getRawVelocity() to Encoder.getCorrectedVelocity() to enable a\r\n        //  compensation method\r\n\r\n        return Arrays.asList(\r\n                encoderTicksToInches(leftEncoder.getCorrectedVelocity()),\r\n                encoderTicksToInches(rightEncoder.getCorrectedVelocity()),\r\n                encoderTicksToInches(frontEncoder.getCorrectedVelocity())\r\n        );\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/StandardTrackingWheelLocalizer.java	(date 1676995377236)
@@ -32,8 +32,8 @@
     public static double WHEEL_RADIUS = 0.98; // in
     public static double GEAR_RATIO = 1; // output (wheel) speed / input (encoder) speed
 
-    public static double LATERAL_DISTANCE = 4.3; // in; distance between the left and right wheels
-    public static double FORWARD_OFFSET = -1.5; // in; offset of the lateral wheel
+    public static double LATERAL_DISTANCE = 8.97637795277; // in; distance between the left and right wheels
+    public static double FORWARD_OFFSET = -2.51968503937; // in; offset of the lateral wheel
 
     public static double X_MULTIPLIER = 1; // Multiplier in the X direction
     public static double Y_MULTIPLIER = 1; // Multiplier in the Y direction
@@ -47,12 +47,12 @@
                 new Pose2d(FORWARD_OFFSET, 0, Math.toRadians(90)) // front
         ));
 
-        leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "leftFront"));
-        rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "rightFront"));
-        frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "leftBack"));
+        leftEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "left_front"));
+        rightEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "right_front"));
+        frontEncoder = new Encoder(hardwareMap.get(DcMotorEx.class, "left_back"));
 
-        // TODO: reverse any encoders using Encoder.setDirection(Encoder.Direction.REVERSE)
-        leftEncoder.setDirection(Encoder.Direction.REVERSE);
+        // TODO: reverse any encoders using Encoder.setDirection(Encoder.Direction.REVERSE
+         rightEncoder.setDirection(Encoder.Direction.REVERSE);
     }
 
     public static double encoderTicksToInches(double ticks) {
@@ -77,9 +77,9 @@
         //  compensation method
 
         return Arrays.asList(
-                encoderTicksToInches(leftEncoder.getCorrectedVelocity()),
-                encoderTicksToInches(rightEncoder.getCorrectedVelocity()),
-                encoderTicksToInches(frontEncoder.getCorrectedVelocity())
+                encoderTicksToInches(leftEncoder.getCorrectedVelocity() * X_MULTIPLIER),
+                encoderTicksToInches(rightEncoder.getCorrectedVelocity() * X_MULTIPLIER),
+                encoderTicksToInches(frontEncoder.getCorrectedVelocity() * Y_MULTIPLIER)
         );
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\r\n\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ACCEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ANG_ACCEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ANG_VEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_VEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\r\n\r\nimport androidx.annotation.NonNull;\r\n\r\nimport com.acmerobotics.dashboard.config.Config;\r\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\r\nimport com.acmerobotics.roadrunner.drive.DriveSignal;\r\nimport com.acmerobotics.roadrunner.drive.MecanumDrive;\r\nimport com.acmerobotics.roadrunner.followers.HolonomicPIDVAFollower;\r\nimport com.acmerobotics.roadrunner.followers.TrajectoryFollower;\r\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\r\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\r\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.AngularVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.MecanumVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.MinVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.ProfileAccelerationConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryAccelerationConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryVelocityConstraint;\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.hardware.lynx.LynxModule;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\r\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\r\n\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequence;\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequenceBuilder;\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequenceRunner;\r\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/*\r\n * Simple mecanum drive hardware implementation for REV hardware.\r\n */\r\n@Config\r\npublic class SampleMecanumDrive extends MecanumDrive {\r\n    public static PIDCoefficients TRANSLATIONAL_PID = new PIDCoefficients(0, 0, 0);\r\n    public static PIDCoefficients HEADING_PID = new PIDCoefficients(0, 0, 0);\r\n\r\n    public static double LATERAL_MULTIPLIER = 1;\r\n\r\n    public static double VX_WEIGHT = 1;\r\n    public static double VY_WEIGHT = 1;\r\n    public static double OMEGA_WEIGHT = 1;\r\n\r\n    private TrajectorySequenceRunner trajectorySequenceRunner;\r\n\r\n    private static final TrajectoryVelocityConstraint VEL_CONSTRAINT = getVelocityConstraint(MAX_VEL, MAX_ANG_VEL, TRACK_WIDTH);\r\n    private static final TrajectoryAccelerationConstraint ACCEL_CONSTRAINT = getAccelerationConstraint(MAX_ACCEL);\r\n\r\n    private TrajectoryFollower follower;\r\n\r\n    private DcMotorEx leftFront, leftRear, rightRear, rightFront;\r\n    private List<DcMotorEx> motors;\r\n\r\n    private BNO055IMU imu;\r\n    private VoltageSensor batteryVoltageSensor;\r\n\r\n    public SampleMecanumDrive(HardwareMap hardwareMap) {\r\n        super(kV, kA, kStatic, TRACK_WIDTH, TRACK_WIDTH, LATERAL_MULTIPLIER);\r\n\r\n        follower = new HolonomicPIDVAFollower(TRANSLATIONAL_PID, TRANSLATIONAL_PID, HEADING_PID,\r\n                new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5);\r\n\r\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\r\n\r\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\r\n\r\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\r\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\r\n        }\r\n\r\n        // TODO: adjust the names of the following hardware devices to match your configuration\r\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\r\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\r\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\r\n        imu.initialize(parameters);\r\n\r\n        // TODO: If the hub containing the IMU you are using is mounted so that the \"REV\" logo does\r\n        // not face up, remap the IMU axes so that the z-axis points upward (normal to the floor.)\r\n        //\r\n        //             | +Z axis\r\n        //             |\r\n        //             |\r\n        //             |\r\n        //      _______|_____________     +Y axis\r\n        //     /       |_____________/|__________\r\n        //    /   REV / EXPANSION   //\r\n        //   /       / HUB         //\r\n        //  /_______/_____________//\r\n        // |_______/_____________|/\r\n        //        /\r\n        //       / +X axis\r\n        //\r\n        // This diagram is derived from the axes in section 3.4 https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bno055-ds000.pdf\r\n        // and the placement of the dot/orientation from https://docs.revrobotics.com/rev-control-system/control-system-overview/dimensions#imu-location\r\n        //\r\n        // For example, if +Y in this diagram faces downwards, you would use AxisDirection.NEG_Y.\r\n        // BNO055IMUUtil.remapZAxis(imu, AxisDirection.NEG_Y);\r\n\r\n        leftFront = hardwareMap.get(DcMotorEx.class, \"leftFront\");\r\n        leftRear = hardwareMap.get(DcMotorEx.class, \"leftBack\");\r\n        rightRear = hardwareMap.get(DcMotorEx.class, \"rightBack\");\r\n        rightFront = hardwareMap.get(DcMotorEx.class, \"rightFront\");\r\n\r\n        motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);\r\n\r\n        for (DcMotorEx motor : motors) {\r\n            MotorConfigurationType motorConfigurationType = motor.getMotorType().clone();\r\n            motorConfigurationType.setAchieveableMaxRPMFraction(1.0);\r\n            motor.setMotorType(motorConfigurationType);\r\n        }\r\n\r\n        if (RUN_USING_ENCODER) {\r\n            setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        }\r\n\r\n        setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        if (RUN_USING_ENCODER && MOTOR_VELO_PID != null) {\r\n            setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\r\n        }\r\n\r\n        // TODO: reverse any motors using DcMotor.setDirection()\r\n        rightFront.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        rightRear.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n        // TODO: if desired, use setLocalizer() to change the localization method\r\n        setLocalizer(new StandardTrackingWheelLocalizer(hardwareMap));\r\n\r\n        trajectorySequenceRunner = new TrajectorySequenceRunner(follower, HEADING_PID);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\r\n        return new TrajectoryBuilder(startPose, VEL_CONSTRAINT, ACCEL_CONSTRAINT);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\r\n        return new TrajectoryBuilder(startPose, reversed, VEL_CONSTRAINT, ACCEL_CONSTRAINT);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\r\n        return new TrajectoryBuilder(startPose, startHeading, VEL_CONSTRAINT, ACCEL_CONSTRAINT);\r\n    }\r\n\r\n    public TrajectorySequenceBuilder trajectorySequenceBuilder(Pose2d startPose) {\r\n        return new TrajectorySequenceBuilder(\r\n                startPose,\r\n                VEL_CONSTRAINT, ACCEL_CONSTRAINT,\r\n                MAX_ANG_VEL, MAX_ANG_ACCEL\r\n        );\r\n    }\r\n\r\n    public void turnAsync(double angle) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(\r\n                trajectorySequenceBuilder(getPoseEstimate())\r\n                        .turn(angle)\r\n                        .build()\r\n        );\r\n    }\r\n\r\n    public void turn(double angle) {\r\n        turnAsync(angle);\r\n        waitForIdle();\r\n    }\r\n\r\n    public void followTrajectoryAsync(Trajectory trajectory) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(\r\n                trajectorySequenceBuilder(trajectory.start())\r\n                        .addTrajectory(trajectory)\r\n                        .build()\r\n        );\r\n    }\r\n\r\n    public void followTrajectory(Trajectory trajectory) {\r\n        followTrajectoryAsync(trajectory);\r\n        waitForIdle();\r\n    }\r\n\r\n    public void followTrajectorySequenceAsync(TrajectorySequence trajectorySequence) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(trajectorySequence);\r\n    }\r\n\r\n    public void followTrajectorySequence(TrajectorySequence trajectorySequence) {\r\n        followTrajectorySequenceAsync(trajectorySequence);\r\n        waitForIdle();\r\n    }\r\n\r\n    public Pose2d getLastError() {\r\n        return trajectorySequenceRunner.getLastPoseError();\r\n    }\r\n\r\n    public void update() {\r\n        updatePoseEstimate();\r\n        DriveSignal signal = trajectorySequenceRunner.update(getPoseEstimate(), getPoseVelocity());\r\n        if (signal != null) setDriveSignal(signal);\r\n    }\r\n\r\n    public void waitForIdle() {\r\n        while (!Thread.currentThread().isInterrupted() && isBusy())\r\n            update();\r\n    }\r\n\r\n    public boolean isBusy() {\r\n        return trajectorySequenceRunner.isBusy();\r\n    }\r\n\r\n    public void setMode(DcMotor.RunMode runMode) {\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setMode(runMode);\r\n        }\r\n    }\r\n\r\n    public void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior zeroPowerBehavior) {\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setZeroPowerBehavior(zeroPowerBehavior);\r\n        }\r\n    }\r\n\r\n    public void setPIDFCoefficients(DcMotor.RunMode runMode, PIDFCoefficients coefficients) {\r\n        PIDFCoefficients compensatedCoefficients = new PIDFCoefficients(\r\n                coefficients.p, coefficients.i, coefficients.d,\r\n                coefficients.f * 12 / batteryVoltageSensor.getVoltage()\r\n        );\r\n\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setPIDFCoefficients(runMode, compensatedCoefficients);\r\n        }\r\n    }\r\n\r\n    public void setWeightedDrivePower(Pose2d drivePower) {\r\n        Pose2d vel = drivePower;\r\n\r\n        if (Math.abs(drivePower.getX()) + Math.abs(drivePower.getY())\r\n                + Math.abs(drivePower.getHeading()) > 1) {\r\n            // re-normalize the powers according to the weights\r\n            double denom = VX_WEIGHT * Math.abs(drivePower.getX())\r\n                    + VY_WEIGHT * Math.abs(drivePower.getY())\r\n                    + OMEGA_WEIGHT * Math.abs(drivePower.getHeading());\r\n\r\n            vel = new Pose2d(\r\n                    VX_WEIGHT * drivePower.getX(),\r\n                    VY_WEIGHT * drivePower.getY(),\r\n                    OMEGA_WEIGHT * drivePower.getHeading()\r\n            ).div(denom);\r\n        }\r\n\r\n        setDrivePower(vel);\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public List<Double> getWheelPositions() {\r\n        List<Double> wheelPositions = new ArrayList<>();\r\n        for (DcMotorEx motor : motors) {\r\n            wheelPositions.add(encoderTicksToInches(motor.getCurrentPosition()));\r\n        }\r\n        return wheelPositions;\r\n    }\r\n\r\n    @Override\r\n    public List<Double> getWheelVelocities() {\r\n        List<Double> wheelVelocities = new ArrayList<>();\r\n        for (DcMotorEx motor : motors) {\r\n            wheelVelocities.add(encoderTicksToInches(motor.getVelocity()));\r\n        }\r\n        return wheelVelocities;\r\n    }\r\n\r\n    @Override\r\n    public void setMotorPowers(double v, double v1, double v2, double v3) {\r\n        leftFront.setPower(v);\r\n        leftRear.setPower(v1);\r\n        rightRear.setPower(v2);\r\n        rightFront.setPower(v3);\r\n    }\r\n\r\n    @Override\r\n    public double getRawExternalHeading() {\r\n        return imu.getAngularOrientation().firstAngle;\r\n    }\r\n\r\n    @Override\r\n    public Double getExternalHeadingVelocity() {\r\n        return (double) imu.getAngularVelocity().zRotationRate;\r\n    }\r\n\r\n    public static TrajectoryVelocityConstraint getVelocityConstraint(double maxVel, double maxAngularVel, double trackWidth) {\r\n        return new MinVelocityConstraint(Arrays.asList(\r\n                new AngularVelocityConstraint(maxAngularVel),\r\n                new MecanumVelocityConstraint(maxVel, trackWidth)\r\n        ));\r\n    }\r\n\r\n    public static TrajectoryAccelerationConstraint getAccelerationConstraint(double maxAccel) {\r\n        return new ProfileAccelerationConstraint(maxAccel);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleMecanumDrive.java	(date 1676995377245)
@@ -117,10 +117,10 @@
         // For example, if +Y in this diagram faces downwards, you would use AxisDirection.NEG_Y.
         // BNO055IMUUtil.remapZAxis(imu, AxisDirection.NEG_Y);
 
-        leftFront = hardwareMap.get(DcMotorEx.class, "leftFront");
-        leftRear = hardwareMap.get(DcMotorEx.class, "leftBack");
-        rightRear = hardwareMap.get(DcMotorEx.class, "rightBack");
-        rightFront = hardwareMap.get(DcMotorEx.class, "rightFront");
+        leftFront = hardwareMap.get(DcMotorEx.class, "left_front");
+        leftRear = hardwareMap.get(DcMotorEx.class, "left_back");
+        rightRear = hardwareMap.get(DcMotorEx.class, "right_back");
+        rightFront = hardwareMap.get(DcMotorEx.class, "right_front");
 
         motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.drive;\r\n\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ACCEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ANG_ACCEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_ANG_VEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MAX_VEL;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.MOTOR_VELO_PID;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.RUN_USING_ENCODER;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.TRACK_WIDTH;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.encoderTicksToInches;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kA;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kStatic;\r\nimport static org.firstinspires.ftc.teamcode.drive.DriveConstants.kV;\r\n\r\nimport androidx.annotation.NonNull;\r\n\r\nimport com.acmerobotics.dashboard.config.Config;\r\nimport com.acmerobotics.roadrunner.control.PIDCoefficients;\r\nimport com.acmerobotics.roadrunner.drive.DriveSignal;\r\nimport com.acmerobotics.roadrunner.drive.TankDrive;\r\nimport com.acmerobotics.roadrunner.followers.TankPIDVAFollower;\r\nimport com.acmerobotics.roadrunner.followers.TrajectoryFollower;\r\nimport com.acmerobotics.roadrunner.geometry.Pose2d;\r\nimport com.acmerobotics.roadrunner.trajectory.Trajectory;\r\nimport com.acmerobotics.roadrunner.trajectory.TrajectoryBuilder;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.AngularVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.MinVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.ProfileAccelerationConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.TankVelocityConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryAccelerationConstraint;\r\nimport com.acmerobotics.roadrunner.trajectory.constraints.TrajectoryVelocityConstraint;\r\nimport com.qualcomm.hardware.bosch.BNO055IMU;\r\nimport com.qualcomm.hardware.lynx.LynxModule;\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\nimport com.qualcomm.robotcore.hardware.VoltageSensor;\r\nimport com.qualcomm.robotcore.hardware.configuration.typecontainers.MotorConfigurationType;\r\n\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequence;\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequenceBuilder;\r\nimport org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequenceRunner;\r\nimport org.firstinspires.ftc.teamcode.util.LynxModuleUtil;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\n/*\r\n * Simple tank drive hardware implementation for REV hardware.\r\n */\r\n@Config\r\npublic class SampleTankDrive extends TankDrive {\r\n    public static PIDCoefficients AXIAL_PID = new PIDCoefficients(0, 0, 0);\r\n    public static PIDCoefficients CROSS_TRACK_PID = new PIDCoefficients(0, 0, 0);\r\n    public static PIDCoefficients HEADING_PID = new PIDCoefficients(0, 0, 0);\r\n\r\n    public static double VX_WEIGHT = 1;\r\n    public static double OMEGA_WEIGHT = 1;\r\n\r\n    private TrajectorySequenceRunner trajectorySequenceRunner;\r\n\r\n    private static final TrajectoryVelocityConstraint VEL_CONSTRAINT = getVelocityConstraint(MAX_VEL, MAX_ANG_VEL, TRACK_WIDTH);\r\n    private static final TrajectoryAccelerationConstraint accelConstraint = getAccelerationConstraint(MAX_ACCEL);\r\n\r\n    private TrajectoryFollower follower;\r\n\r\n    private List<DcMotorEx> motors, leftMotors, rightMotors;\r\n    private BNO055IMU imu;\r\n\r\n    private VoltageSensor batteryVoltageSensor;\r\n\r\n    public SampleTankDrive(HardwareMap hardwareMap) {\r\n        super(kV, kA, kStatic, TRACK_WIDTH);\r\n\r\n        follower = new TankPIDVAFollower(AXIAL_PID, CROSS_TRACK_PID,\r\n                new Pose2d(0.5, 0.5, Math.toRadians(5.0)), 0.5);\r\n\r\n        LynxModuleUtil.ensureMinimumFirmwareVersion(hardwareMap);\r\n\r\n        batteryVoltageSensor = hardwareMap.voltageSensor.iterator().next();\r\n\r\n        for (LynxModule module : hardwareMap.getAll(LynxModule.class)) {\r\n            module.setBulkCachingMode(LynxModule.BulkCachingMode.AUTO);\r\n        }\r\n\r\n        // TODO: adjust the names of the following hardware devices to match your configuration\r\n        imu = hardwareMap.get(BNO055IMU.class, \"imu\");\r\n        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();\r\n        parameters.angleUnit = BNO055IMU.AngleUnit.RADIANS;\r\n        imu.initialize(parameters);\r\n\r\n        // TODO: If the hub containing the IMU you are using is mounted so that the \"REV\" logo does\r\n        // not face up, remap the IMU axes so that the z-axis points upward (normal to the floor.)\r\n        //\r\n        //             | +Z axis\r\n        //             |\r\n        //             |\r\n        //             |\r\n        //      _______|_____________     +Y axis\r\n        //     /       |_____________/|__________\r\n        //    /   REV / EXPANSION   //\r\n        //   /       / HUB         //\r\n        //  /_______/_____________//\r\n        // |_______/_____________|/\r\n        //        /\r\n        //       / +X axis\r\n        //\r\n        // This diagram is derived from the axes in section 3.4 https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bno055-ds000.pdf\r\n        // and the placement of the dot/orientation from https://docs.revrobotics.com/rev-control-system/control-system-overview/dimensions#imu-location\r\n        //\r\n        // For example, if +Y in this diagram faces downwards, you would use AxisDirection.NEG_Y.\r\n        // BNO055IMUUtil.remapZAxis(imu, AxisDirection.NEG_Y);\r\n\r\n        // add/remove motors depending on your robot (e.g., 6WD)\r\n        DcMotorEx leftFront = hardwareMap.get(DcMotorEx.class, \"leftFront\");\r\n        DcMotorEx leftRear = hardwareMap.get(DcMotorEx.class, \"leftRear\");\r\n        DcMotorEx rightRear = hardwareMap.get(DcMotorEx.class, \"rightRear\");\r\n        DcMotorEx rightFront = hardwareMap.get(DcMotorEx.class, \"rightFront\");\r\n\r\n        motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);\r\n        leftMotors = Arrays.asList(leftFront, leftRear);\r\n        rightMotors = Arrays.asList(rightFront, rightRear);\r\n\r\n        for (DcMotorEx motor : motors) {\r\n            MotorConfigurationType motorConfigurationType = motor.getMotorType().clone();\r\n            motorConfigurationType.setAchieveableMaxRPMFraction(1.0);\r\n            motor.setMotorType(motorConfigurationType);\r\n        }\r\n\r\n        if (RUN_USING_ENCODER) {\r\n            setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n        }\r\n\r\n        setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        if (RUN_USING_ENCODER && MOTOR_VELO_PID != null) {\r\n            setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER, MOTOR_VELO_PID);\r\n        }\r\n\r\n        // TODO: reverse any motors using DcMotor.setDirection()\r\n\r\n        // TODO: if desired, use setLocalizer() to change the localization method\r\n        // for instance, setLocalizer(new ThreeTrackingWheelLocalizer(...));\r\n\r\n        trajectorySequenceRunner = new TrajectorySequenceRunner(follower, HEADING_PID);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose) {\r\n        return new TrajectoryBuilder(startPose, VEL_CONSTRAINT, accelConstraint);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, boolean reversed) {\r\n        return new TrajectoryBuilder(startPose, reversed, VEL_CONSTRAINT, accelConstraint);\r\n    }\r\n\r\n    public TrajectoryBuilder trajectoryBuilder(Pose2d startPose, double startHeading) {\r\n        return new TrajectoryBuilder(startPose, startHeading, VEL_CONSTRAINT, accelConstraint);\r\n    }\r\n\r\n    public TrajectorySequenceBuilder trajectorySequenceBuilder(Pose2d startPose) {\r\n        return new TrajectorySequenceBuilder(\r\n                startPose,\r\n                VEL_CONSTRAINT, accelConstraint,\r\n                MAX_ANG_VEL, MAX_ANG_ACCEL\r\n        );\r\n    }\r\n\r\n    public void turnAsync(double angle) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(\r\n                trajectorySequenceBuilder(getPoseEstimate())\r\n                        .turn(angle)\r\n                        .build()\r\n        );\r\n    }\r\n\r\n    public void turn(double angle) {\r\n        turnAsync(angle);\r\n        waitForIdle();\r\n    }\r\n\r\n    public void followTrajectoryAsync(Trajectory trajectory) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(\r\n                trajectorySequenceBuilder(trajectory.start())\r\n                        .addTrajectory(trajectory)\r\n                        .build()\r\n        );\r\n    }\r\n\r\n    public void followTrajectory(Trajectory trajectory) {\r\n        followTrajectoryAsync(trajectory);\r\n        waitForIdle();\r\n    }\r\n\r\n    public void followTrajectorySequenceAsync(TrajectorySequence trajectorySequence) {\r\n        trajectorySequenceRunner.followTrajectorySequenceAsync(trajectorySequence);\r\n    }\r\n\r\n    public void followTrajectorySequence(TrajectorySequence trajectorySequence) {\r\n        followTrajectorySequenceAsync(trajectorySequence);\r\n        waitForIdle();\r\n    }\r\n\r\n    public Pose2d getLastError() {\r\n        return trajectorySequenceRunner.getLastPoseError();\r\n    }\r\n\r\n\r\n    public void update() {\r\n        updatePoseEstimate();\r\n        DriveSignal signal = trajectorySequenceRunner.update(getPoseEstimate(), getPoseVelocity());\r\n        if (signal != null) setDriveSignal(signal);\r\n    }\r\n\r\n    public void waitForIdle() {\r\n        while (!Thread.currentThread().isInterrupted() && isBusy())\r\n            update();\r\n    }\r\n\r\n    public boolean isBusy() {\r\n        return trajectorySequenceRunner.isBusy();\r\n    }\r\n\r\n    public void setMode(DcMotor.RunMode runMode) {\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setMode(runMode);\r\n        }\r\n    }\r\n\r\n    public void setZeroPowerBehavior(DcMotor.ZeroPowerBehavior zeroPowerBehavior) {\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setZeroPowerBehavior(zeroPowerBehavior);\r\n        }\r\n    }\r\n\r\n    public void setPIDFCoefficients(DcMotor.RunMode runMode, PIDFCoefficients coefficients) {\r\n        PIDFCoefficients compensatedCoefficients = new PIDFCoefficients(\r\n                coefficients.p, coefficients.i, coefficients.d,\r\n                coefficients.f * 12 / batteryVoltageSensor.getVoltage()\r\n        );\r\n        for (DcMotorEx motor : motors) {\r\n            motor.setPIDFCoefficients(runMode, compensatedCoefficients);\r\n        }\r\n    }\r\n\r\n    public void setWeightedDrivePower(Pose2d drivePower) {\r\n        Pose2d vel = drivePower;\r\n\r\n        if (Math.abs(drivePower.getX()) + Math.abs(drivePower.getHeading()) > 1) {\r\n            // re-normalize the powers according to the weights\r\n            double denom = VX_WEIGHT * Math.abs(drivePower.getX())\r\n                    + OMEGA_WEIGHT * Math.abs(drivePower.getHeading());\r\n\r\n            vel = new Pose2d(\r\n                    VX_WEIGHT * drivePower.getX(),\r\n                    0,\r\n                    OMEGA_WEIGHT * drivePower.getHeading()\r\n            ).div(denom);\r\n        }\r\n\r\n        setDrivePower(vel);\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public List<Double> getWheelPositions() {\r\n        double leftSum = 0, rightSum = 0;\r\n        for (DcMotorEx leftMotor : leftMotors) {\r\n            leftSum += encoderTicksToInches(leftMotor.getCurrentPosition());\r\n        }\r\n        for (DcMotorEx rightMotor : rightMotors) {\r\n            rightSum += encoderTicksToInches(rightMotor.getCurrentPosition());\r\n        }\r\n        return Arrays.asList(leftSum / leftMotors.size(), rightSum / rightMotors.size());\r\n    }\r\n\r\n    public List<Double> getWheelVelocities() {\r\n        double leftSum = 0, rightSum = 0;\r\n        for (DcMotorEx leftMotor : leftMotors) {\r\n            leftSum += encoderTicksToInches(leftMotor.getVelocity());\r\n        }\r\n        for (DcMotorEx rightMotor : rightMotors) {\r\n            rightSum += encoderTicksToInches(rightMotor.getVelocity());\r\n        }\r\n        return Arrays.asList(leftSum / leftMotors.size(), rightSum / rightMotors.size());\r\n    }\r\n\r\n    @Override\r\n    public void setMotorPowers(double v, double v1) {\r\n        for (DcMotorEx leftMotor : leftMotors) {\r\n            leftMotor.setPower(v);\r\n        }\r\n        for (DcMotorEx rightMotor : rightMotors) {\r\n            rightMotor.setPower(v1);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public double getRawExternalHeading() {\r\n        return imu.getAngularOrientation().firstAngle;\r\n    }\r\n\r\n    @Override\r\n    public Double getExternalHeadingVelocity() {\r\n        return (double) imu.getAngularVelocity().zRotationRate;\r\n    }\r\n\r\n    public static TrajectoryVelocityConstraint getVelocityConstraint(double maxVel, double maxAngularVel, double trackWidth) {\r\n        return new MinVelocityConstraint(Arrays.asList(\r\n                new AngularVelocityConstraint(maxAngularVel),\r\n                new TankVelocityConstraint(maxVel, trackWidth)\r\n        ));\r\n    }\r\n\r\n    public static TrajectoryAccelerationConstraint getAccelerationConstraint(double maxAccel) {\r\n        return new ProfileAccelerationConstraint(maxAccel);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/drive/SampleTankDrive.java	(date 1676995377254)
@@ -113,10 +113,10 @@
         // BNO055IMUUtil.remapZAxis(imu, AxisDirection.NEG_Y);
 
         // add/remove motors depending on your robot (e.g., 6WD)
-        DcMotorEx leftFront = hardwareMap.get(DcMotorEx.class, "leftFront");
-        DcMotorEx leftRear = hardwareMap.get(DcMotorEx.class, "leftRear");
-        DcMotorEx rightRear = hardwareMap.get(DcMotorEx.class, "rightRear");
-        DcMotorEx rightFront = hardwareMap.get(DcMotorEx.class, "rightFront");
+        DcMotorEx leftFront = hardwareMap.get(DcMotorEx.class, "left_front");
+        DcMotorEx leftRear = hardwareMap.get(DcMotorEx.class, "left_back");
+        DcMotorEx rightRear = hardwareMap.get(DcMotorEx.class, "right_back");
+        DcMotorEx rightFront = hardwareMap.get(DcMotorEx.class, "right_front");
 
         motors = Arrays.asList(leftFront, leftRear, rightRear, rightFront);
         leftMotors = Arrays.asList(leftFront, leftRear);
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AutonomousEN.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AutonomousEN.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AutonomousEN.java
new file mode 100644
--- /dev/null	(date 1676995377283)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/AutonomousEN.java	(date 1676995377283)
@@ -0,0 +1,4 @@
+package org.firstinspires.ftc.teamcode.auton;
+
+public class AutonomousEN {
+}
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/autonDean.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/autonDean.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/autonDean.java
new file mode 100644
--- /dev/null	(date 1676995377218)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auton/autonDean.java	(date 1676995377218)
@@ -0,0 +1,78 @@
+///*
+// * Copyright (c) 2021 OpenFTC Team
+// *
+// * Permission is hereby granted, free of charge, to any person obtaining a copy
+// * of this software and associated documentation files (the "Software"), to deal
+// * in the Software without restriction, including without limitation the rights
+// * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// * copies of the Software, and to permit persons to whom the Software is
+// * furnished to do so, subject to the following conditions:
+// *
+// * The above copyright notice and this permission notice shall be included in all
+// * copies or substantial portions of the Software.
+// * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// * FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
+// * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// * SOFTWARE.
+// */
+//
+//package org.firstinspires.ftc.teamcode.auton;
+//
+//import com.acmerobotics.roadrunner.geometry.Pose2d;
+//import com.acmerobotics.roadrunner.geometry.Vector2d;
+//import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+//import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+//import com.qualcomm.robotcore.hardware.DcMotor;
+//import com.qualcomm.robotcore.hardware.DcMotorSimple;
+//import com.qualcomm.robotcore.hardware.Servo;
+//
+//import org.firstinspires.ftc.teamcode.drive.SampleMecanumDrive;
+//import org.firstinspires.ftc.teamcode.trajectorysequence.TrajectorySequence;
+//
+//@Autonomous(name = "Igor 1+1", group = "Concept")
+//public class Igoroneplusone extends LinearOpMode {
+//
+//    private DcMotor armMotor1;
+//    private DcMotor armMotor2;
+//    private Servo intakeServo;
+//
+//    public void armMovement(int armTicks) throws InterruptedException {
+//        double multiplier = 0;
+//        if(armTicks >= 0){multiplier = 1.0;}
+//        armMotor1.setTargetPosition(armTicks);
+//        armMotor2.setTargetPosition(armTicks);
+//        armMotor1.setPower(0.5 * multiplier);
+//        armMotor2.setPower(0.5 * multiplier);
+//        armMotor1.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+//        armMotor2.setMode(DcMotor.RunMode.RUN_TO_POSITION);
+//
+//        while (armMotor1.isBusy() && opModeIsActive()) {
+//            idle();
+//        }
+//    }
+//    public void servoPositioning(double servoPosition) {intakeServo.setPosition(servoPosition);}
+//
+//    @Override
+//    public void runOpMode() throws InterruptedException{
+//        armMotor1 = hardwareMap.get(DcMotor.class, "armmotor1");
+//        armMotor2= hardwareMap.get(DcMotor.class, "armmotor2");
+//
+//        intakeServo = hardwareMap.get(Servo.class, "Intake");
+//
+//        armMotor1.setDirection(DcMotorSimple.Direction.FORWARD);
+//        armMotor2.setDirection(DcMotorSimple.Direction.REVERSE);
+//
+//        SampleMecanumDrive drivetrain = new SampleMecanumDrive(hardwareMap);
+//
+//        TrajectorySequence LeftPark = drivetrain.trajectorySequenceBuilder(new Pose2d(0, 0, Math.toRadians(0)))
+//                .lineTo(new Vector2d(0, 20))
+//                .lineTo(new Vector2d(20,20))
+//                .build();
+//
+//        waitForStart();
+//        drivetrain.followTrajectorySequence(LeftPark);
+//    }
+//}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Drivetrain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.robotParts;\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\npublic class Drivetrain extends RobotPart{\r\n    private DcMotorEx leftFront;\r\n    private DcMotorEx rightFront;\r\n    private DcMotorEx leftBack;\r\n    private DcMotorEx rightBack;\r\n\r\n    private double maxSpeed = 0.4;\r\n\r\n    public void init(HardwareMap map) {\r\n        leftFront = map.get(DcMotorEx.class, \"left_front\");\r\n        rightFront = map.get(DcMotorEx.class, \"right_front\");\r\n        leftBack = map.get(DcMotorEx.class, \"left_back\");\r\n        rightBack = map.get(DcMotorEx.class, \"right_back\");\r\n\r\n        // reverse motors where necessary\r\n        leftFront.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        leftBack.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n        leftFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        leftBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        rightFront.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        rightBack.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        // motors\r\n//        motors.put(\"leftFront\", leftFront);\r\n//        motors.put(\"rightFront\", rightFront);\r\n//        motors.put(\"leftBack\", leftBack);\r\n//        motors.put(\"rightBack\", rightBack);\r\n//        resetEncoders();\r\n    }\r\n\r\n    public void drive(double forward, double right, double rotate) {\r\n        double leftFrontPower = forward + right + rotate;\r\n        double rightFrontPower = forward - right - rotate;\r\n        double rightRearPower = forward + right - rotate;\r\n        double leftRearPower = forward - right + rotate;\r\n        double maxPower = 1.0;\r\n\r\n        maxPower = Math.max(maxPower, Math.abs(leftFrontPower));\r\n        maxPower = Math.max(maxPower, Math.abs(rightFrontPower));\r\n        maxPower = Math.max(maxPower, Math.abs(rightRearPower));\r\n        maxPower = Math.max(maxPower, Math.abs(leftRearPower));\r\n\r\n\r\n        leftFront.setPower(maxSpeed * (leftFrontPower / maxPower));\r\n        rightFront.setPower(maxSpeed * (rightFrontPower / maxPower));\r\n        rightBack.setPower(maxSpeed * rightRearPower / maxPower);\r\n        leftBack.setPower(maxSpeed * (leftRearPower / maxPower));\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Drivetrain.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Drivetrain.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Drivetrain.java	(revision 87f5a574d133a2201b4147151be71d193e23d94d)
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/robotParts/Drivetrain.java	(date 1676995377271)
@@ -11,7 +11,7 @@
     private DcMotorEx leftBack;
     private DcMotorEx rightBack;
 
-    private double maxSpeed = 0.4;
+    public static double maxSpeed = 0.6;
 
     public void init(HardwareMap map) {
         leftFront = map.get(DcMotorEx.class, "left_front");
